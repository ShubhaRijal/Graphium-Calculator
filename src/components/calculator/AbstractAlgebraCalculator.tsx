import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';

export function AbstractAlgebraCalculator() {
  const [inputs, setInputs] = useState<Record<string, string>>({});
  const [result, setResult] = useState<string>('');

  const updateInput = (key: string, value: string) => {
    setInputs(prev => ({ ...prev, [key]: value }));
  };

  const gcd = (a: number, b: number): number => b === 0 ? a : gcd(b, a % b);

  const analyzeGroup = () => {
    try {
      const n = parseInt(inputs.groupOrder || '6');
      
      const results: string[] = [];
      results.push(`Group Analysis: Order n = ${n}`);
      results.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      
      // â„¤/nâ„¤ (cyclic group)
      results.push(`\nğŸ“ â„¤/${n}â„¤ (Cyclic Group of order ${n})`);
      
      // Find generators
      const generators: number[] = [];
      for (let a = 1; a < n; a++) {
        if (gcd(a, n) === 1) generators.push(a);
      }
      results.push(`  Generators: {${generators.join(', ')}}`);
      results.push(`  Ï†(${n}) = ${generators.length} (Euler's totient)`);
      
      // Subgroups (divisors of n)
      const subgroups: number[] = [];
      for (let d = 1; d <= n; d++) {
        if (n % d === 0) subgroups.push(d);
      }
      results.push(`  Subgroup orders (divisors): {${subgroups.join(', ')}}`);
      
      // Element orders in â„¤/nâ„¤
      results.push(`\n  Element orders in â„¤/${n}â„¤:`);
      for (let a = 0; a < Math.min(n, 12); a++) {
        const order = n / gcd(a, n);
        results.push(`    ord(${a}) = ${a === 0 ? 1 : order}`);
      }
      if (n > 12) results.push(`    ... (showing first 12 elements)`);
      
      // Lagrange's theorem
      results.push(`\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
      results.push(`Lagrange's Theorem:`);
      results.push(`  For any subgroup H of G: |H| divides |G|`);
      results.push(`  For any element a: ord(a) divides |G|`);
      
      // Check if abelian (all cyclic groups are abelian)
      results.push(`\nProperties:`);
      results.push(`  Is cyclic: Yes (generated by ${generators[0]})`);
      results.push(`  Is abelian: Yes (all cyclic groups are)`);
      
      // Isomorphism
      const isPrime = (p: number) => {
        if (p < 2) return false;
        for (let i = 2; i * i <= p; i++) if (p % i === 0) return false;
        return true;
      };
      
      if (isPrime(n)) {
        results.push(`  â„¤/${n}â„¤ is a field (${n} is prime)`);
      }
      
      // Factor n for structure theorem
      const factorize = (num: number): number[] => {
        const factors: number[] = [];
        for (let p = 2; p <= num; p++) {
          while (num % p === 0) {
            factors.push(p);
            num /= p;
          }
        }
        return factors;
      };
      
      const factors = factorize(n);
      if (factors.length > 1) {
        const uniqueFactors = [...new Set(factors)];
        const factorCounts = uniqueFactors.map(p => ({
          p,
          count: factors.filter(f => f === p).length
        }));
        results.push(`\n  Structure: â„¤/${n}â„¤ â‰… ${factorCounts.map(f => `â„¤/${f.p}^${f.count}â„¤`).join(' Ã— ')}`);
      }
      
      setResult(results.join('\n'));
    } catch (error) {
      setResult(`Error: ${error instanceof Error ? error.message : 'Invalid input'}`);
    }
  };

  const analyzeRing = () => {
    try {
      const n = parseInt(inputs.ringMod || '12');
      
      const results: string[] = [];
      results.push(`Ring â„¤/${n}â„¤ Analysis`);
      results.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      
      // Units (invertible elements)
      const units: number[] = [];
      for (let a = 1; a < n; a++) {
        if (gcd(a, n) === 1) units.push(a);
      }
      results.push(`\nUnits (â„¤/${n}â„¤)* = {${units.join(', ')}}`);
      results.push(`  |Units| = Ï†(${n}) = ${units.length}`);
      
      // Zero divisors
      const zeroDivisors: number[] = [];
      for (let a = 1; a < n; a++) {
        if (gcd(a, n) !== 1) zeroDivisors.push(a);
      }
      results.push(`\nZero divisors: {${zeroDivisors.length > 0 ? zeroDivisors.join(', ') : 'none'}}`);
      
      // Nilpotent elements
      const nilpotents: number[] = [];
      for (let a = 0; a < n; a++) {
        let power = a;
        for (let k = 1; k <= n; k++) {
          power = (power * a) % n;
          if (power === 0 && a !== 0) {
            nilpotents.push(a);
            break;
          }
        }
      }
      results.push(`Nilpotent elements: {${nilpotents.length > 0 ? nilpotents.join(', ') : 'none'}}`);
      
      // Idempotent elements (aÂ² = a)
      const idempotents: number[] = [];
      for (let a = 0; a < n; a++) {
        if ((a * a) % n === a) idempotents.push(a);
      }
      results.push(`Idempotent elements: {${idempotents.join(', ')}}`);
      
      // Check properties
      results.push(`\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
      results.push(`Properties:`);
      
      const isPrime = zeroDivisors.length === 0;
      results.push(`  Integral domain: ${isPrime ? 'Yes' : 'No'}`);
      results.push(`  Field: ${isPrime && n > 1 ? 'Yes' : 'No'}`);
      results.push(`  Commutative: Yes`);
      
      // Multiplicative table (small n only)
      if (n <= 8) {
        results.push(`\nMultiplication table:`);
        let header = 'Ã—  |';
        for (let i = 0; i < n; i++) header += ` ${i}`;
        results.push(header);
        results.push('â”€â”€â”€â”¼' + 'â”€â”€'.repeat(n));
        for (let i = 0; i < n; i++) {
          let row = `${i}  |`;
          for (let j = 0; j < n; j++) {
            row += ` ${(i * j) % n}`;
          }
          results.push(row);
        }
      }
      
      setResult(results.join('\n'));
    } catch (error) {
      setResult(`Error: ${error instanceof Error ? error.message : 'Invalid input'}`);
    }
  };

  const analyzePermutation = () => {
    try {
      const permStr = inputs.permutation || '3,1,4,2';
      const perm = permStr.split(',').map(s => parseInt(s.trim()));
      const n = perm.length;
      
      const results: string[] = [];
      results.push(`Permutation Analysis`);
      results.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      
      results.push(`\nÏƒ = (${perm.join(' ')})`);
      results.push(`  in S_${n}`);
      
      // Two-line notation
      results.push(`\nTwo-line notation:`);
      results.push(`  (${Array.from({length: n}, (_, i) => i + 1).join(' ')})`);
      results.push(`  (${perm.join(' ')})`);
      
      // Cycle decomposition
      const visited = new Set<number>();
      const cycles: number[][] = [];
      
      for (let i = 1; i <= n; i++) {
        if (!visited.has(i)) {
          const cycle: number[] = [];
          let current = i;
          while (!visited.has(current)) {
            visited.add(current);
            cycle.push(current);
            current = perm[current - 1];
          }
          if (cycle.length > 1) cycles.push(cycle);
          else if (cycle.length === 1) cycles.push(cycle); // Include fixed points
        }
      }
      
      results.push(`\nCycle decomposition:`);
      const cycleStr = cycles.map(c => `(${c.join(' ')})`).join('');
      results.push(`  Ïƒ = ${cycleStr || 'identity'}`);
      
      // Cycle type
      const cycleType = cycles.map(c => c.length).sort((a, b) => b - a);
      results.push(`  Cycle type: [${cycleType.join(', ')}]`);
      
      // Order of permutation (LCM of cycle lengths)
      const lcm = (a: number, b: number): number => (a * b) / gcd(a, b);
      const order = cycleType.reduce((acc, len) => lcm(acc, len), 1);
      results.push(`  Order: ${order}`);
      
      // Sign/parity
      const transpositions = cycles.reduce((sum, c) => sum + c.length - 1, 0);
      const sign = transpositions % 2 === 0 ? '+1 (even)' : '-1 (odd)';
      results.push(`  Sign: ${sign}`);
      results.push(`  In A_${n}: ${transpositions % 2 === 0 ? 'Yes' : 'No'}`);
      
      // Inverse
      const inverse = new Array(n);
      for (let i = 0; i < n; i++) {
        inverse[perm[i] - 1] = i + 1;
      }
      results.push(`\nInverse Ïƒâ»Â¹ = (${inverse.join(' ')})`);
      
      // Fixed points
      const fixedPoints = perm.filter((p, i) => p === i + 1);
      results.push(`Fixed points: ${fixedPoints.length > 0 ? fixedPoints.join(', ') : 'none'}`);
      
      setResult(results.join('\n'));
    } catch (error) {
      setResult(`Error: ${error instanceof Error ? error.message : 'Invalid input'}`);
    }
  };

  const showGroupTheory = () => {
    const results = `Group Theory Reference
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“š Group Axioms (G, â€¢):
1. Closure: aâ€¢b âˆˆ G for all a,b âˆˆ G
2. Associativity: (aâ€¢b)â€¢c = aâ€¢(bâ€¢c)
3. Identity: âˆƒe: eâ€¢a = aâ€¢e = a
4. Inverse: âˆ€a âˆƒaâ»Â¹: aâ€¢aâ»Â¹ = aâ»Â¹â€¢a = e

ğŸ“š Abelian Group: Also satisfies
   Commutativity: aâ€¢b = bâ€¢a

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Important Theorems:

Lagrange's Theorem:
  |H| divides |G| for subgroup H âŠ† G

Cayley's Theorem:
  Every group is isomorphic to a 
  subgroup of some symmetric group

First Isomorphism Theorem:
  If Ï†: G â†’ H is a homomorphism, then
  G/ker(Ï†) â‰… im(Ï†)

Sylow Theorems:
  For |G| = p^nÂ·m (p prime, gcd(p,m)=1):
  1. Sylow p-subgroups exist
  2. All Sylow p-subgroups are conjugate
  3. Number of Sylow p-subgroups â‰¡ 1 (mod p)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Common Groups:

â„¤_n: Cyclic group of order n
S_n: Symmetric group (n! elements)
A_n: Alternating group (n!/2 elements)
D_n: Dihedral group (2n elements)
V_4: Klein four-group (4 elements)
Q_8: Quaternion group (8 elements)`;

    setResult(results);
  };

  const analyzeField = () => {
    try {
      const p = parseInt(inputs.fieldPrime || '7');
      
      const results: string[] = [];
      results.push(`Finite Field ğ”½_${p} (= â„¤/${p}â„¤)`);
      results.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      
      // Check if prime
      const isPrime = (n: number) => {
        if (n < 2) return false;
        for (let i = 2; i * i <= n; i++) if (n % i === 0) return false;
        return true;
      };
      
      if (!isPrime(p)) {
        results.push(`\nâš ï¸ ${p} is not prime!`);
        results.push(`   â„¤/${p}â„¤ is NOT a field.`);
        setResult(results.join('\n'));
        return;
      }
      
      results.push(`\nâœ“ ${p} is prime, so ğ”½_${p} is a field.`);
      
      // Elements
      results.push(`\nElements: {0, 1, 2, ..., ${p - 1}}`);
      results.push(`Characteristic: ${p}`);
      
      // Multiplicative group
      results.push(`\n(ğ”½_${p})* = ğ”½_${p} \\ {0} is cyclic of order ${p - 1}`);
      
      // Find primitive root (generator)
      const findPrimitiveRoot = () => {
        for (let g = 2; g < p; g++) {
          let isPrimitive = true;
          const required = p - 1;
          let power = 1;
          for (let i = 1; i < required; i++) {
            power = (power * g) % p;
            if (power === 1) {
              isPrimitive = false;
              break;
            }
          }
          if (isPrimitive && (power * g) % p === 1) return g;
        }
        return -1;
      };
      
      const primitiveRoot = findPrimitiveRoot();
      results.push(`Primitive root (generator): ${primitiveRoot}`);
      
      // Show powers of primitive root
      if (p <= 19) {
        results.push(`\nPowers of ${primitiveRoot}:`);
        let power = 1;
        const powers = [];
        for (let i = 0; i < p - 1; i++) {
          powers.push(`${primitiveRoot}^${i} = ${power}`);
          power = (power * primitiveRoot) % p;
        }
        results.push(`  ${powers.join(', ')}`);
      }
      
      // Quadratic residues
      const quadResidues: number[] = [];
      for (let a = 1; a < p; a++) {
        quadResidues.push((a * a) % p);
      }
      const uniqueQR = [...new Set(quadResidues)].sort((a, b) => a - b);
      results.push(`\nQuadratic residues: {${uniqueQR.join(', ')}}`);
      results.push(`  (exactly (p-1)/2 = ${(p - 1) / 2} residues)`);
      
      // Fermat's little theorem
      results.push(`\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
      results.push(`Fermat's Little Theorem:`);
      results.push(`  a^(${p - 1}) â‰¡ 1 (mod ${p}) for all a â‰¢ 0`);
      results.push(`  a^${p} â‰¡ a (mod ${p}) for all a`);
      
      setResult(results.join('\n'));
    } catch (error) {
      setResult(`Error: ${error instanceof Error ? error.message : 'Invalid input'}`);
    }
  };

  return (
    <Card className="glass-panel">
      <CardHeader className="pb-3">
        <CardTitle className="text-lg font-semibold text-primary">Abstract Algebra</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <Tabs defaultValue="groups" className="w-full">
          <TabsList className="grid w-full grid-cols-4 mb-4">
            <TabsTrigger value="groups">Groups</TabsTrigger>
            <TabsTrigger value="rings">Rings</TabsTrigger>
            <TabsTrigger value="fields">Fields</TabsTrigger>
            <TabsTrigger value="perms">Permutations</TabsTrigger>
          </TabsList>

          <TabsContent value="groups" className="space-y-4">
            <div>
              <Label className="text-xs">Cyclic Group Order (â„¤/nâ„¤)</Label>
              <Input placeholder="n" onChange={(e) => updateInput('groupOrder', e.target.value)} />
            </div>
            <Button onClick={analyzeGroup} className="w-full">Analyze â„¤/nâ„¤</Button>
            <Button onClick={showGroupTheory} className="w-full" variant="outline">Group Theory Reference</Button>
          </TabsContent>

          <TabsContent value="rings" className="space-y-4">
            <div>
              <Label className="text-xs">Ring â„¤/nâ„¤</Label>
              <Input placeholder="n" onChange={(e) => updateInput('ringMod', e.target.value)} />
            </div>
            <Button onClick={analyzeRing} className="w-full">Analyze Ring</Button>
          </TabsContent>

          <TabsContent value="fields" className="space-y-4">
            <div>
              <Label className="text-xs">Prime p for Field ğ”½_p</Label>
              <Input placeholder="p (prime)" onChange={(e) => updateInput('fieldPrime', e.target.value)} />
            </div>
            <Button onClick={analyzeField} className="w-full">Analyze Field</Button>
          </TabsContent>

          <TabsContent value="perms" className="space-y-4">
            <div>
              <Label className="text-xs">Permutation (comma-separated, e.g., "3,1,4,2")</Label>
              <Input placeholder="3,1,4,2" onChange={(e) => updateInput('permutation', e.target.value)} />
            </div>
            <div className="text-xs text-muted-foreground">
              Enter where each position maps to: if 1â†’3, 2â†’1, 3â†’4, 4â†’2, enter "3,1,4,2"
            </div>
            <Button onClick={analyzePermutation} className="w-full">Analyze Permutation</Button>
          </TabsContent>
        </Tabs>

        {result && (
          <pre className="mt-4 p-3 bg-muted/50 rounded-lg text-xs font-mono whitespace-pre-wrap overflow-x-auto max-h-80 overflow-y-auto">
            {result}
          </pre>
        )}
      </CardContent>
    </Card>
  );
}
